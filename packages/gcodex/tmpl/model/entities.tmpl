{{define "ent.tmpl"}}
// Code generated by gcodex, DO NOT EDIT.
// Output:./dist/ent/schema/*.go
// TODO: Extension API support HTTP Restfull API/grpc logging/metric/tracing
// Copyright 2019-present Facebook Inc. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.
package {{.PackageName}}

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/dialect"
	"entgo.io/ent/schema/index"
	{{- if len .Edges | gt 0}}
"entgo.io/ent/schema/edge"
	{{end}}
	"entgo.io/ent/dialect/entsql"
)

// {{.Name}} holds the schema definition for the {{.Name}} entity.
type {{.Name}} struct {
	ent.Schema
}

// Fields of the {{.Name}}.
func ({{.Name}}) Fields() []ent.Field {
	return []ent.Field{
		{{range $col:=.Columns}}
		{{- if eq $col.FieldType "string"}}
			{{if $col.Enumerable}}
			.Enum({{$col.Name}}).Values({{$col.EnumVals}}...)
			{{- else}}
			field.String({{$col.Name}})
			{{- end}}
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag -}},omitempty"`)
			{{- end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{- end}}
			{{- if gt $col.MaxLen 0 -}}
			 .Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}). Validate(MaxRuneCount({{$col.MaxLen}}))
			{{- end}}
			{{- if gt $col.MinLen 0}}
			.Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}). Validate(MinRuneCount({{$col.MinLen}}))
			{{end -}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable()
			{{end}}
			{{if $col.IsOptional}}
			.Optional().Nillable()
			{{else}}
			.NotEmpty(),
			{{end}}
		{{else if eq $col.FieldType "int"}}
			{{if $col.Enumerable}}
			.Enum({{$col.Name}}).Values({{$col.EnumVals}}...)
			{{else if eq $col.Precision 8}}
			field.Int8({{$col.Name}})
			{{else if eq $col.Precision 16}}
			field.Int16({{$col.Name}})
			{{else if or $col.Precision 32}}
			field.Int32({{$col.Name}})
			{{else if eq $col.Precision 64}}
			field.Int64({{$col.Name}})
			{{end}}
			{{if $col.IsNonNegative}}
			.NonNegative()
			{{else}}
			.Negative()
			{{end}}
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			{{if gt $col.MaxLen 0}}
			 .Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}). Validate(MaxRuneCount({{$col.MaxLen}}))
			{{end}}
			{{if gt $col.MinLen 0}}
			.Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}). Validate(MinRuneCount({{$col.MinLen}}))
			{{end}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable(),
			{{end}}
		{{else if eq $col.FieldType "uint"}}
			{{if $col.Enumerable}}
			.Enum({{$col.Name}}).Values({{$col.EnumVals}}...)
			{{else if eq $col.Precision 8}}
			field.Uint8({{$col.Name}})
			{{else if eq $col.Precision 16}}
			field.Uint16({{$col.Name}})
			{{else if or $col.Precision 32}}
			field.Uint32({{$col.Name}})
			{{else if eq $col.Precision 64}}
			field.Uint64({{$col.Name}})
			{{end}}
			.NonNegative()
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			{{if gt $col.MaxLen 0}}
			 .Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}). Validate(MaxRuneCount({{$col.MaxLen}}))
			{{end}}
			{{if gt $col.MinLen 0}}
			.Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}). Validate(MinRuneCount({{$col.MinLen}}))
			{{end}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable(),
			{{end}}
		{{else if eq $col.FieldType "float"}}
			{{if $col.Enumerable}}
			.Enum({{$col.Name}}).Values({{$col.EnumVals}}...)
			{{else if or $col.Precision 32}}
			field.Float32({{$col.Name}})
			.SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",   // Override MySQL.
                dialect.Postgres: "numeric",        // Override Postgres.
            })
			{{else if eq $col.Precision 64}}
			field.Float({{$col.Name}})
			.SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",   // Override MySQL.
                dialect.Postgres: "numeric",        // Override Postgres.
            })
			{{end}}
			{{if $col.IsNonNegative}}
			.NonNegative()
			{{else}}
			.Negative()
			{{end}}
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			{{if gt $col.MaxLen 0}}
			 .Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}). Validate(MaxRuneCount({{$col.MaxLen}}))
			{{end}}
			{{if gt $col.MinLen 0}}
			.Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}). Validate(MinRuneCount({{$col.MinLen}}))
			{{end}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable(),
			{{end}}
		{{else if eq $col.FieldType "decimal"}}
			{{if $col.Enumerable}}
			.Enum({{$col.Name}}).Values({{$col.EnumVals}}...)
			{{else if eq $col.Precision 64}}
			field.Float({{$col.Name}})
			.SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",   // Override MySQL.
                dialect.Postgres: "numeric",        // Override Postgres.
            })
			{{end}}
			{{if $col.IsNonNegative}}
			.NonNegative()
			{{else}}
			.Negative()
			{{end}}
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			{{if gt $col.MaxLen 0}}
			 .Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}). Validate(MaxRuneCount({{$col.MaxLen}}))
			{{end}}
			{{if gt $col.MinLen 0}}
			.Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}). Validate(MinRuneCount({{$col.MinLen}}))
			{{end}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable(),
			{{end}}
		{{else if eq $col.FieldType "bool"}}
			field.Bool({{$col.Name}})
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			.Default(DefaultValue[{{$col.FieldType}}])
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable(),
			{{end}}
		{{else if eq $col.FieldType "datetime"}}
			// Add a new field with CURRENT_TIMESTAMP
			// as a default value to all previous rows.
			field.Time({{$col.Name}})
			.Annotations(&entsql.Annotation{
                Default: "CURRENT_TIMESTAMP",
            })
			{{if ne $col.StructTag ""}}
			.StructTag(`json:"{{$col.StructTag}},omitempty"`)
			{{end}}
			{{if ne $col.StorageKey ""}}
			.StorageKey({{$col.StorageKey}})
			{{end}}
			{{if $col.Comment}}
			.Comment({{$col.Comment}})
			{{end}}
			{{if $col.IsSensitive}}
			.Sensitive()
			{{end}}
			{{if $col.IsImmutable}}
			.Immutable()
			{{end}}
			{{if $col.IsOptional}}
			.Optional().Nillable()
			{{else}}
			.NotEmpty(),
			{{end}}
		{{else}}
			return nil
		{{end}}
	{{end}}
	}

}

// Indexes of the {{.Name}}.
func ({{.Name}}) Indexes() []ent.Index {
	return []ent.Indexes{
		{{range $col:=.Columns}}
			{{if $col.IsUnique}}
			index.Fields({{$col.Name}}).StorageKey({{$col.UidxName}})
            .Annotations(entsql.Desc()).Unique(),
			{{else if $col.IsIndex}}
			index.Fields({{$col.Name}}).StorageKey({{$col.IdxName}}).Annotations(entsql.Desc()),
			{{else}}
				return nil
			{{end}}
		{{end}}
	}
}

// Edges of the {{.Name}}.
func ({{.Name}}) Edges() []ent.Edge {
	return []ent.Edge{
		{{range $ed :=.Edges}}
			{{if ne $ed.To ""}}
				edge.To({{$.ed.To}},{{.Name}}.Type),
			{{else if ne $ed.From ""}}
				edge.From({{$.ed.From}}, {{.Name}}.Type).Ref({{.Name}}).Unique(),
			{{else}}
				return nil
			{{end}}
		{{end}}
	}
}

// Annotations of the {{.Name}}.
func ({{.Name}}) Annotations() []schema.Annotation {
    return []schema.Annotation{
        entsql.Annotation{Table: {{.Comment}}},
    }
}

// MaxRuneCount validates the rune length of a string by using the unicode/utf8 package.
func MaxRuneCount(maxLen int) func(s string) error {
    return func(s string) error {
        if utf8.RuneCountInString(s) > maxLen {
            return errors.New("value is more than the max length")
        }
        return nil
    }
}

// MinRuneCount validates the rune length of a string by using the unicode/utf8 package.
func MinRuneCount(minLen int)func(s string)error{
	return func(s string)error{
	if utf8.RuneCountInString(s) < minLen{
		return errors.New("value is less than the min length")
	}
}

{{end}}