{{define "ent.tmpl"}}
// Code generated by gcodex, DO NOT EDIT.
// Output:./dist/ent/schema/*.go
// TODO: Extension API support HTTP Restfull API/grpc logging/metric/tracing
// Copyright 2019-present Facebook Inc. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.
package {{.PackageName}}

import (
	"unicode/utf8"
	"errors"

	"entgo.io/ent"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/index"
	{{- if len .Edges | gt 0}}
	"entgo.io/ent/schema/edge"
	{{end}}
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
)

// {{.Name}} holds the schema definition for the {{.Name}} entity.
type {{.Name}} struct {
	ent.Schema
}

// Fields of the {{.Name}}.
func ({{.Name}}) Fields() []ent.Field {
	{{if gt (len .Columns) 0 -}}
	return []ent.Field{
		{{range $col:=.Columns}}
		{{- if eq $col.FieldType "string"}}
			{{- if $col.Enumerable -}}
			field.Enum("{{$col.Name}}").Values([]string{ {{$col.EnumVals}} }...).
			{{- else -}}
			field.String("{{$col.Name}}").
			{{- end}}
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{- if and (gt $col.MaxLen 0) (not $col.Enumerable) -}}
			 Annotations(entsql.Annotation{
        		Size: {{$col.MaxLen}},
    			}).Validate(MaxRuneCount({{$col.MaxLen}})).
			{{- end}}
			{{- if and (gt $col.MinLen 0) (not $col.Enumerable) -}}
			Annotations(entsql.Annotation{
        		Size: {{$col.MinLen}},
    			}).Validate(MinRuneCount({{$col.MinLen}})).
			{{end -}}
			Default("{{$col.DefaultVal}}").
			{{- if $col.Comment}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{- if $col.IsSensitive -}}
			Sensitive().
			{{- end}}
			{{- if $col.IsImmutable -}}
			Immutable().
			{{- end}}
			{{if $col.IsOptional -}}
			Optional().Nillable(),
			{{else -}}
			NotEmpty(),
			{{- end}}
		{{- else if eq $col.FieldType "int"}}
			{{- if $col.Enumerable -}}
			field.Enum("{{$col.Name}}").Values([]int{ {{$col.EnumVals}} }...).
			{{else if eq $col.Precision 8 -}}
			field.Int8("{{$col.Name}}").
			{{else if eq $col.Precision 16 -}}
			field.Int16("{{$col.Name}}").
			{{else if eq $col.Precision 32 -}}
			field.Int32("{{$col.Name}}").
			{{else if eq $col.Precision 64 -}}
			field.Int64("{{$col.Name}}").
			{{else -}}
			field.Int("{{$col.Name}}").
			{{- end}}
			{{- if $col.IsNonNegative -}}
			NonNegative().
			{{- else -}}
			Negative().
			{{- end}}
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{- if $col.IsImmutable -}}
			Immutable().
			{{- end}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "uint"}}
			{{- if $col.Enumerable -}}
			field.Enum("{{$col.Name}}").Values([]uint{ {{$col.EnumVals}} }...).
			{{else if eq $col.Precision 8 -}}
			field.Uint8("{{$col.Name}}").
			{{else if eq $col.Precision 16 -}}
			field.Uint16("{{$col.Name}}").
			{{else if eq $col.Precision 32 -}}
			field.Uint32("{{$col.Name}}").
			{{else if eq $col.Precision 64 -}}
			field.Uint64("{{$col.Name}}").
			{{- else -}}
			field.Uint("{{$col.Name}}").
			{{- end -}}
			NonNegative().
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{end -}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "float"}}
			{{- if $col.Enumerable}}
			field.Enum("{{$col.Name}}").Values([]float{ {{$col.EnumVals}} }...).
			{{- else -}}
			field.Float32("{{$col.Name}}").
			SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",
                dialect.Postgres: "numeric",
            }).
			{{- end}}
			{{if ne $col.StructTag ""  -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{end -}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "float64"}}
			{{- if $col.Enumerable}}
			field.Enum("{{$col.Name}}").Values([]float{ {{$col.EnumVals}} }...).
			{{- else -}}
			field.Float("{{$col.Name}}").
			SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",
                dialect.Postgres: "numeric",
            }).
			{{- end}}
			{{if ne $col.StructTag ""  -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{end -}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "decimal" -}}
			field.Float("{{$col.Name}}").
			SchemaType(map[string]string{
                dialect.MySQL:    "decimal({{$col.Precision}},{{$col.Scale}})",
                dialect.Postgres: "numeric",
            }).
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{end -}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "bool" -}}
			field.Bool("{{$col.Name}}").
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{end -}}
			Default({{$col.DefaultVal}}),
		{{- else if eq $col.FieldType "datetime" -}}
			field.Time("{{$col.Name}}").
			{{if ne $col.StructTag "" -}}
			StructTag(`json:"{{$col.StructTag}},omitempty"`).
			{{- end}}
			{{if ne $col.StorageKey "" -}}
			StorageKey("{{$col.StorageKey}}").
			{{- end}}
			{{if $col.Comment -}}
			Comment("{{$col.Comment}}").
			{{- end}}
			{{if $col.IsImmutable -}}
			Immutable().
			{{- end}}
			{{- if $col.IsOptional -}}
			Optional().Nillable().
			{{- end -}}
			Annotations(&entsql.Annotation{
                Default: "CURRENT_TIMESTAMP",
            }),
		{{else}}
			return nil
		{{end}}
	{{end -}}
	}
	{{- else}}
		return nil
	{{- end}}
}

// Indexes of the {{.Name}}.
func ({{.Name}}) Indexes() []ent.Index {
	{{if gt (len .Columns) 0 -}}
		return []ent.Index{
		{{- range $col:=.Columns}}
			{{- if $col.IsUnique}}
			index.Fields("{{$col.Name}}").StorageKey("{{$col.UidxName}}").Annotations(entsql.Desc()).Unique(),
			{{- else if $col.IsIndex}}
			index.Fields("{{$col.Name}}").StorageKey("{{$col.IdxName}}").Annotations(entsql.Desc()),
			{{end}}
		{{end -}}
		}
	{{- else}}
		return nil
	{{- end}}
}

// Edges of the {{.Name}}.
func ({{.Name}}) Edges() []ent.Edge {
	{{if gt (len .Edges) 0 -}}
	return []ent.Edge{
	{{- range $ed :=.Edges}}
		{{- if ne $ed.To ""}}
		edge.To("{{$.ed.To}}",{{.Name}}.Type),
		{{- else if ne $ed.From ""}}
		edge.From("{{$.ed.From}}", {{.Name}}.Type).Ref("{{.Name}}").Unique(),
		{{end}}		
	{{end -}}
	}
	{{- else -}}
		return nil
	{{- end}}
}

// Annotations of the {{.Name}}.
func ({{.Name}}) Annotations() []schema.Annotation {
    return []schema.Annotation{
        entsql.Annotation{Table:"{{.Comment}}"},
    }
}


// MaxRuneCount validates the rune length of a string by using the unicode/utf8 package.
func MaxRuneCount(maxLen int) func(s string) error {
    return func(s string) error {
        if utf8.RuneCountInString(s) > maxLen {
            return errors.New("value is less than the min length")
        }
        return nil
    }
}

// MinRuneCount validates the rune length of a string by using the unicode/utf8 package.
func MinRuneCount(minLen int)func(s string)error{
	return func(s string)error{
	if utf8.RuneCountInString(s) < minLen{
		return errors.New("value is less than the min length")
		}
		return nil
	}
	
}

{{end}}